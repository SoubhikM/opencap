Only in ../OPENCAP-MD-NOV30: .DS_Store
Only in .: .git
Only in .: .github
Only in .: .readthedocs.yml
diff -r ./README.md ../OPENCAP-MD-NOV30/README.md
8c8
< | **Build Status**  | [![][gh-actions-img]][gh-actions-url] [![][cov-img]][cov-url] [![][codeql-img]][codeql-url] |
---
> | **Build Status**  | [![][gh-actions-img]][gh-actions-url] [![][cov-img]][cov-url] [![][lgtm-img]][lgtm-url] |
15,16c15,16
< [codeql-img]: https://github.com/gayverjr/opencap/actions/workflows/codeql.yml/badge.svg
< [codeql-url]: https://github.com/gayverjr/opencap/actions
---
> [lgtm-img]: https://img.shields.io/lgtm/grade/cpp/g/gayverjr/opencap.svg?logo=lgtm&logoWidth=18
> [lgtm-url]: https://lgtm.com/projects/g/gayverjr/opencap/context:cpp
diff -r ./environment.yml ../OPENCAP-MD-NOV30/environment.yml
1c1
< name: pyopencap
---
> name: myclone
3,4c3
<    - anaconda
<    - conda-forge
---
>   - defaults
6,14c5,138
<    - eigen
<    - hdf5
<    - cmake
<    - numpy
<    - gcc_linux-64
<    - pip:
<       - docutils==0.16
<       - sphinx-rtd-theme
<       - sphinx
---
>   - _libgcc_mutex=0.1=main
>   - _openmp_mutex=4.5=1_gnu
>   - blas=1.0=mkl
>   - ca-certificates=2022.3.29=h06a4308_0
>   - certifi=2021.10.8=py39h06a4308_2
>   - cudatoolkit=10.1.243=h6bb024c_0
>   - cudnn=7.6.5=cuda10.1_0
>   - cupy=8.3.0=py39hcaf9a05_0
>   - fastrlock=0.6=py39h2531618_0
>   - intel-openmp=2021.4.0=h06a4308_3561
>   - joblib=1.1.0=pyhd3eb1b0_0
>   - ld_impl_linux-64=2.35.1=h7274673_9
>   - libffi=3.3=he6710b0_2
>   - libgcc-ng=9.3.0=h5101ec6_17
>   - libgomp=9.3.0=h5101ec6_17
>   - libstdcxx-ng=9.3.0=hd4cf53a_17
>   - mkl=2021.4.0=h06a4308_640
>   - mkl-service=2.4.0=py39h7f8727e_0
>   - mkl_fft=1.3.1=py39hd3c417c_0
>   - mkl_random=1.2.2=py39h51133e4_0
>   - nccl=2.8.3.1=hcaf9a05_0
>   - ncurses=6.3=h7f8727e_2
>   - numpy-base=1.21.5=py39hf524024_1
>   - openssl=1.1.1n=h7f8727e_0
>   - pip=21.2.4=py39h06a4308_0
>   - python=3.9.7=h12debd9_1
>   - readline=8.1.2=h7f8727e_1
>   - setuptools=58.0.4=py39h06a4308_0
>   - six=1.16.0=pyhd3eb1b0_1
>   - sqlite=3.38.0=hc218d9a_0
>   - tk=8.6.11=h1ccaba5_0
>   - tzdata=2021e=hda174b7_0
>   - wheel=0.37.1=pyhd3eb1b0_0
>   - xz=5.2.5=h7b6447c_0
>   - zlib=1.2.11=h7f8727e_4
>   - pip:
>     - aiohttp==3.8.1
>     - aiosignal==1.2.0
>     - anyio==3.5.0
>     - argon2-cffi==21.3.0
>     - argon2-cffi-bindings==21.2.0
>     - asttokens==2.0.5
>     - async-timeout==4.0.2
>     - attrs==21.4.0
>     - babel==2.9.1
>     - backcall==0.2.0
>     - beautifulsoup4==4.10.0
>     - bleach==4.1.0
>     - cffi==1.15.0
>     - charset-normalizer==2.0.12
>     - csaps==1.1.0
>     - cycler==0.11.0
>     - debugpy==1.6.0
>     - decorator==5.1.1
>     - defusedxml==0.7.1
>     - entrypoints==0.4
>     - executing==0.8.3
>     - fonttools==4.31.2
>     - frozenlist==1.3.0
>     - h5py==3.6.0
>     - idna==3.3
>     - ipykernel==6.10.0
>     - ipython==8.2.0
>     - ipython-genutils==0.2.0
>     - jedi==0.18.1
>     - jinja2==3.1.1
>     - json5==0.9.6
>     - jsonschema==4.4.0
>     - jupyter-client==7.2.1
>     - jupyter-core==4.9.2
>     - jupyter-server==1.16.0
>     - jupyterlab==3.3.2
>     - jupyterlab-pygments==0.1.2
>     - jupyterlab-server==2.12.0
>     - kiwisolver==1.4.2
>     - markupsafe==2.1.1
>     - matplotlib==3.5.1
>     - matplotlib-inline==0.1.3
>     - mistune==0.8.4
>     - multidict==6.0.2
>     - nbclassic==0.3.7
>     - nbclient==0.5.13
>     - nbconvert==6.4.5
>     - nbformat==5.2.0
>     - nest-asyncio==1.5.4
>     - notebook==6.4.10
>     - notebook-shim==0.1.0
>     - numpy==1.22.3
>     - packaging==21.3
>     - pandas==1.4.1
>     - pandocfilters==1.5.0
>     - parso==0.8.3
>     - pathlib2==2.3.7.post1
>     - pegamoid==2.6.2
>     - pexpect==4.8.0
>     - pickleshare==0.7.5
>     - pillow==9.0.1
>     - prometheus-client==0.13.1
>     - prompt-toolkit==3.0.28
>     - psutil==5.9.0
>     - ptyprocess==0.7.0
>     - pure-eval==0.2.2
>     - pycparser==2.21
>     - pyfftw==0.13.0
>     - pygments==2.11.2
>     - pyopencap==1.2.6
>     - pyparsing==3.0.7
>     - pyqt5==5.15.6
>     - pyqt5-qt5==5.15.2
>     - pyqt5-sip==12.10.1
>     - pyrsistent==0.18.1
>     - python-dateutil==2.8.2
>     - pytz==2022.1
>     - pyzmq==22.3.0
>     - qtpy==2.1.0
>     - requests==2.27.1
>     - scipy==1.8.0
>     - send2trash==1.8.0
>     - sniffio==1.2.0
>     - soupsieve==2.3.1
>     - stack-data==0.2.0
>     - terminado==0.13.3
>     - testpath==0.6.0
>     - tornado==6.1
>     - tqdm==4.64.0
>     - traitlets==5.1.1
>     - urllib3==1.26.9
>     - vtk==9.1.0
>     - wcwidth==0.2.5
>     - webencodings==0.5.1
>     - websocket-client==1.3.2
>     - wslink==1.6.1
>     - yarl==1.7.2
> prefix: /home/soubhik/anaconda3/envs/myclone
diff -r ./examples/pyopencap/pyscf/eomea_ccsd.py ../OPENCAP-MD-NOV30/examples/pyopencap/pyscf/eomea_ccsd.py
249,252c249,250
<     r1_spin = spatial2spin_ea((r1_curr,dummyR1))
<     r2_spin=spatial2spin_ea((dummyR2,r2_curr,dummyR2,dummyR2))
<     l1_spin = spatial2spin_ea((l1_curr,dummyR1))
<     l2_spin = spatial2spin_ea((dummyR2,l2_curr,dummyR2,dummyR2))
---
>     r1_spin,r2_spin = spatial2spin_ea((r1_curr,dummyR1),(dummyR2,r2_curr,dummyR2,dummyR2))
>     l1_spin,l2_spin = spatial2spin_ea((l1_curr,dummyR1),(dummyR2,l2_curr,dummyR2,dummyR2))
Only in ../OPENCAP-MD-NOV30/opencap: .DS_Store
diff -r ./opencap/CMakeLists.txt ../OPENCAP-MD-NOV30/opencap/CMakeLists.txt
14c14
< set(CMAKE_CXX_STANDARD_REQUIRED True)
---
> set(CMAKE_CXX_STANDARD_REQUIRED ON)
39c39
<   GIT_TAG        703bd9caab50b139428cea1aaff9974ebee5742e # release-1.10.0
---
>   GIT_TAG        release-1.11.0  # Update to the desired version
diff -r ./opencap/bindings/export_classes.cpp ../OPENCAP-MD-NOV30/opencap/bindings/export_classes.cpp
52a53
>         .def("get_ao_capG",&CAP::get_ao_capG,py::arg("ordering")="molden",py::arg("basis_file") = "","Returns CAPG matrix in AO basis. Supported orderings: pyscf, openmolcas, qchem, psi4, molden.")
53a55,56
>     	.def("get_projected_capG",&CAP::get_projected_capG, "Returns CAPG matrix in state basis.")
>     	.def("get_projected_cap_der",&CAP::get_projected_cap_der, "Returns CAP functional derivative matrix in state basis.")
57a61,64
>     	.def("compute_projected_capG",&CAP::compute_projected_capG, "Computes CAPG matrix in state basis using"
>     			" transition density matrices.")
> 		.def("compute_projected_cap_der",&CAP::compute_projected_cap_der, "Computes CAP functional derivative matrix in state basis using"
>     			" transition density matrices.")
63a71,72
> 		.def("qcsoftware_to_opencap_ordering",&CAP::qcsoftware_to_opencap_ordering,py::arg("Matrix to convert"), 
> 				py::arg("ordering"), py::arg("basis_file") = "", "Returns QC-Software to OpenCAP ordering for a matrix.")
diff -r ./opencap/include/AOCAP.h ../OPENCAP-MD-NOV30/opencap/include/AOCAP.h
31c31,32
< 
---
> #include <iostream>
> #include <numgrid.h>
33a35
> #include <fstream>
43a46,48
> 	/** Set to true when constructed from the python interpreter, important for printing
> 	 */
> 	bool python;
82a88,93
> 	/** Computes %CAPG matrix in AO basis via numerical integration.
> 	 */
> 	void computeG_ao_cap_mat(std::vector<std::map<char, Eigen::MatrixXd>> &capG_mat_MD, BasisSet &bs);
> 	/** Computes %CAP functional derivative matrix in AO basis via numerical integration.
> 	 */
> 	void compute_ao_cap_der_mat(std::vector<std::map<char, Eigen::MatrixXd>> &cap_der_mat_MD, BasisSet &bs);
87,89c98,102
< 	std::function<std::vector<double>(std::vector<double> &, std::vector<double> &, 
< 		std::vector<double> &, std::vector<double> &)> cap_func;
< 	void compute_cap_on_grid(Eigen::MatrixXd &cap_mat,BasisSet bs,double* x, double* y, double* z, double *grid_w, int num_points);
---
> 	std::function<std::vector<double>(std::vector<double> &, std::vector<double> &, std::vector<double> &, std::vector<double> &)> cap_func;
> 	
> 	std::function<std::vector<double>(std::vector<double>&, std::vector<double>&)> cap_func_der_x;
> 	std::function<std::vector<double>(std::vector<double>&, std::vector<double>&)> cap_func_der_y;
> 	std::function<std::vector<double>(std::vector<double>&, std::vector<double>&)> cap_func_der_z;
90a104,116
> 
> 	void compute_cap_on_grid(Eigen::MatrixXd &cap_mat,BasisSet bs,double* x, double* y, double* z, double *grid_w, int num_points);
> 	/** Computes %CAP matrix contracted with Basis function derivatives (atom specific).
> 	*/
> 	void computeG_cap_on_grid(std::map<char, Eigen::MatrixXd> &capG_mat,BasisSet bs,double* x, double* y, double* z, double *grid_w, int num_points, 
> 	size_t Atom_idx, size_t centre_numgrid);
> 	/** Computes %CAP derivative matrix contracted with all basis functions.
> 	*/
> 	void compute_cap_der_on_grid(std::map<char, Eigen::MatrixXd> &cap_der_mat,BasisSet bs,double* x, double* y, double* z, double *grid_w, int num_points);
> 	/** SBK added this
> 	*/
> 	void compute_cap_on_grid_dwdR(std::map<char, Eigen::MatrixXd> &cap_mat_dwdR_store, BasisSet bs,double* x, double* y, double* z, 
> 								std::map<char, std::map<int, double>> *grid_w, int num_points);
96a123,132
> 	void integrate_cap_der_numerical(std::map<char, Eigen::MatrixXd>&cap_der_mat, BasisSet bs, size_t atom_idx);
> 	void integrate_cap_der_total_numerical(std::vector<std:: map<char, Eigen::MatrixXd>> &cap_der_mat_MD, BasisSet bs);
> 	void integrate_cap_dwdR_numerical(std::map<char, Eigen::MatrixXd>  &cap_mat_dwdR_store, BasisSet bs, size_t atom_idx);
> 
> 	void integrate_capG_numerical(std::vector<std::map<char, Eigen::MatrixXd>> &capG_mat_MD, BasisSet bs);
> 	void integrate_capG_numerical_individual_atom(std::map<char, Eigen::MatrixXd> &capG_mat, BasisSet bs, size_t Atom_idx);
> 	/** Stores Basis functional value according to the nuclear index, saves time for recalculating it multiple times.
> 	 * Specially for large numbers of Nuclei. Intended to ease the cost of On-the fly MD
> 	*/
> 	std::vector<Eigen::MatrixXd> bf_values_store;
Only in ../OPENCAP-MD-NOV30/opencap/include: BeckeDW1.h
diff -r ./opencap/include/CAP.h ../OPENCAP-MD-NOV30/opencap/include/CAP.h
50a51,56
> 	/** %CAPG matrix in AO basis
> 	 */
> 	std::vector<std::map<char, Eigen::MatrixXd>> AO_CAPG_MAT;
> 	/** %CAP derivative matrix in AO basis
> 	 */
> 	std::vector<std::map<char, Eigen::MatrixXd>> AO_CAP_DER_MAT;
53a60,65
> 	/** %CAPG matrix in correlated many electron basis
> 	 */
> 	std::vector<std::map<char, Eigen::MatrixXd>> CAPG_MAT;
> 	/** %CAP derivative matrix in correlated many electron basis
> 	 */
> 	std::vector<std::map<char, Eigen::MatrixXd>> CAP_DER_MAT;
96a109,114
> 	/** Computes %CAPG in AO basis 
>      */
>     void integrate_capG();
> 	/** Computes %CAP derivative in AO basis 
>      */
>     void integrate_cap_der();
99a118,123
> 	/** Computes %CAPG in state basis
> 	 */
> 	void compute_projected_capG();
> 	/** Computes %CAP derivative in state basis
> 	 */
> 	void compute_projected_cap_der();
110a135,139
> 	/** Returns CAPG matrix in AO basis.
> 	 * \param ordering: order of GTOs
> 	 * \param basis_file: File containing basis set specification. Required for OpenMolcas.
> 	 */
>     std::vector<std::map<char, Eigen::MatrixXd>> get_ao_capG(std::string ordering="molden",std::string basis_file="");
113a143,148
> 	/** Returns CAPG matrix in state basis.
> 	 */
> 	std::vector<std::map<char, Eigen::MatrixXd>> get_projected_capG();
> 	/** Returns CAP derivative matrix in state basis.
> 	 */
> 	std::vector<std::map<char, Eigen::MatrixXd>> get_projected_cap_der();
142a178,181
> 	/** An utility function to create a qchem-software to opencap ordered matrix given an input.
> 	 * Intended for Density matrix check.
> 	*/
> 	Eigen::MatrixXd qcsoftware_to_opencap_ordering(Eigen::MatrixXd mat, std::string ordering, std::string basis_file = "");
diff -r ./opencap/include/Shell.h ../OPENCAP-MD-NOV30/opencap/include/Shell.h
64a65,70
> 	/** Atom ids pertinent to each primitive exps/coeffs
> 	 */
> 	std::vector<size_t> atom_ids;
> 	/** Number of atoms present
> 	*/
> 	std::vector<size_t> grad_atom;
93a100,105
> 	/** Evaluate gradient of basis function with respect to Nuclear poistions (X0, Y0, Z0) (with a given lx ly lz) on grid
> 	 * Needs ``Atom_idx`` varaible for atom specific contribution.
>      */
> 	void evaluateG_on_grid(double* x, double* y, double* z, \
> 	int num_points,size_t lx,size_t ly, size_t lz, \
> 	Eigen::Ref<Eigen::VectorXd> vgrad_X, Eigen::Ref<Eigen::VectorXd> vgrad_Y, Eigen::Ref<Eigen::VectorXd> vgrad_Z, size_t Atom_idx);
103c115
<     void add_primitive(double exp,double coeff);
---
>     void add_primitive(double exp,double coeff, size_t atom_id = -1);
110c122,124
< 
---
> 	/**No of atoms we want to evaluate gradeint for basis function
> 	*/
> 	void grad_atoms(std::vector<size_t> unique_atoms);
diff -r ./opencap/include/molcas_interface.h ../OPENCAP-MD-NOV30/opencap/include/molcas_interface.h
54a55,61
> /*! Read in diagonal Hamiltonian from OpenMolcas output file.
>     \param nstates: number of states
>     \param filename: file location of the OpenMolcas output file.
>     \param rotation_matrix: Eigen matrix of rotation matrix. imension is MxM, where M is number of states.
>     \return Eigen matrix containing the effective Hamiltonian matrix. Dimension is MxM, where M is number of states.
> */
> Eigen::MatrixXd read_sacasscf_h(size_t nstates, std::string filename, Eigen::MatrixXd &rotation_matrix);
diff -r ./opencap/include/qchem_interface.h ../OPENCAP-MD-NOV30/opencap/include/qchem_interface.h
43c43
< /* Reads geometry from Q-Chem fchk file.
---
> /*! Reads geometry from Q-Chem fchk file.
48c48
< /* Reads basis set from Q-Chem fchk file.
---
> /*! Reads basis set from Q-Chem fchk file.
diff -r ./opencap/src/AOCAP.cpp ../OPENCAP-MD-NOV30/opencap/src/AOCAP.cpp
46a47,50
> #include "BeckeDW1.h"
> #include <fstream>
> #include <pybind11/pybind11.h>
> #include <pybind11/eigen.h>
77c81,84
< 	if(compare_strings(cap_type,"box"))
---
> 
> 
> 
> 	if(compare_strings(cap_type,"box")){
78a86
> 	}
128,130c136,150
<     std::cout << "Calculating CAP matrix in AO basis using " << std::to_string(omp_get_max_threads()) << " threads." << std::endl;
<     std::cout << std::setprecision(2) << std::scientific  << "Radial precision: " << radial_precision
<               << " Angular points: " << angular_points << std::endl;
---
> 	std::ostringstream oss;
> 	oss << "Calculating CAP matrix in AO basis using " 
> 		<< std::to_string(omp_get_max_threads()) << " threads.\n"
> 		<< std::setprecision(2) << std::scientific
> 		<< "Radial precision: " << radial_precision 
> 		<< " Angular points: " << angular_points;
> 
> 	std::string message = oss.str();
> 
> 	if (python) {
> 		pybind11::print(message);
> 	} else {
> 		std::cout << message << std::endl;
> 	}
> 	
147c167
< 	#pragma omp parallel for 
---
> 	//#pragma omp parallel for 
166a187
>                 //std::cout <<"Atom: "<< (i+1) << "Nuclear charges: " << nuc_charges[i] <<" " << r_outer<< "< > ?" << r_inner << " l= "<< l << " bragg: "<< get_bragg_angstrom(nuc_charges[i])<<std::endl;
170c191
<                     //std::cout << "Setting alpha min[l] to 0.01" << std::endl; 
---
> 					//std::cout << "Setting alpha min[l] to 0.01" << std::endl; 
196c217
< 		double *cap_values = new double[num_points];
---
> 		//double *cap_values = new double[num_points];
208a230
> 		//std::cout << "Number of radial points: " << num_radial_points << std::endl;
209a232,236
> 		delete [] grid_x_bohr;
> 		delete [] grid_y_bohr;
> 		delete [] grid_z_bohr;
> 		delete [] grid_w;
> 		numgrid_free_atom_grid(context);
218c245
<     std::vector<double> x_vec(x,x+num_points);
---
> 	std::vector<double> x_vec(x,x+num_points);
238c265,266
< 	for(size_t i=0;i<bf_prime.cols();i++)
---
> 
> 	for(size_t i=0;i<bf_prime.cols();i++){
239a268
> 	}
255a285,955
> 
> //This part for the analogus numerical derivative as above but for box cap derivative function.
> void AOCAP::integrate_cap_der_numerical(std::map<char, Eigen::MatrixXd> &cap_der_mat, BasisSet bs, size_t atom_idx)
> {
> 	// funny business happens with GIL if we try to parallelize over atoms when custom python function is used
> 	if(cap_type=="custom")
> 		omp_set_num_threads(1);
>     /*
> 	std::cout << "Calculating CAP functional derivative matrix in AO basis using " << std::to_string(omp_get_max_threads()) << " threads." << std::endl;
>     std::cout << std::setprecision(2) << std::scientific  << "Radial precision: " << radial_precision
>               << " Angular points: " << angular_points << std::endl;
> 	*/
> 
> 	std::ostringstream oss;
> 	oss << "Calculating CAP functional derivative matrix in AO basis using " 
> 		<< std::to_string(omp_get_max_threads()) << " threads.\n";
> 
> 	std::string message = oss.str();
> 
> 	if (python) {
> 		pybind11::print(message);
> 	} else {
> 		std::cout << message << std::endl;
> 	}
> 
> 	size_t num_atoms = atoms.size();
>     double x_coords_bohr[num_atoms];
> 	double y_coords_bohr[num_atoms];
> 	double z_coords_bohr[num_atoms];
> 	int nuc_charges[num_atoms];
> 	for(size_t i=0;i<num_atoms;i++)
> 	{
> 		x_coords_bohr[i]=atoms[i].coords[0];
> 		y_coords_bohr[i]=atoms[i].coords[1];
> 		z_coords_bohr[i]=atoms[i].coords[2];
> 		nuc_charges[i]=atoms[i].Z;
> 		if (atoms[i].Z==0)
> 			nuc_charges[i]=1; //choose bragg radius for H for ghost atoms
> 	}
>     int min_num_angular_points = angular_points;
>     int max_num_angular_points = angular_points;
> 	//#pragma omp parallel for 
> 	//for(size_t i=0;i<num_atoms;i++)
> 	//{
>         // check parameters
>         double alpha_max = bs.alpha_max(atoms[atom_idx]);
>         std::vector<double> alpha_min = bs.alpha_min(atoms[atom_idx],thresh);
>         double r_inner = get_r_inner(radial_precision,
>                                      alpha_max * 2.0); // factor 2.0 to match DIRAC
>         double h = std::numeric_limits<float>::max();
>         double r_outer = 0.0;
>         for (int l = 0; l <= bs.max_L(); l++)
>         {
>             if (alpha_min[l] > 0.0)
>             {
>                 r_outer =
>                 std::max(r_outer,
>                          get_r_outer(radial_precision,
>                                      alpha_min[l],
>                                      l,
>                                      4.0 * get_bragg_angstrom(nuc_charges[atom_idx])));
>                 if(r_outer < r_inner)
>                 {
>                     opencap_throw("Error: r_outer < r_inner, grid cannot be allocated for this basis.");
>                     //std::cout << "Setting alpha min[l] to 0.01" << std::endl; 
>                     //alpha_min[l]=0.01;
>                 }
>                 else
>                 {
>                     h = std::min(h,
>                                  get_h(radial_precision, l, 0.1 * (r_outer - r_inner)));
>                     if(r_outer < h)
>                     {
>                         opencap_throw("Error: r_outer < h, grid cannot be allocated for this basis.");
>                     }
>                 }
>             }
>         }
>         context_t *context = numgrid_new_atom_grid(radial_precision,
> 		                                 min_num_angular_points,
> 		                                 max_num_angular_points,
> 		                                 nuc_charges[atom_idx],
> 		                                 bs.alpha_max(atoms[atom_idx]),
> 		                                 bs.max_L(),
> 		                                 alpha_min.data());
> 		int num_points = numgrid_get_num_grid_points(context);
>         double *grid_x_bohr = new double[num_points];
>         double *grid_y_bohr = new double[num_points];
>         double *grid_z_bohr = new double[num_points];
>         double *grid_w = new double[num_points];
>         numgrid_get_grid(  context,
>                            num_atoms,
>                            atom_idx,
>                            x_coords_bohr,
>                            y_coords_bohr,
>                            z_coords_bohr,
>                            nuc_charges,
>                            grid_x_bohr,
>                            grid_y_bohr,
>                            grid_z_bohr,
>                            grid_w);
>         int num_radial_points = numgrid_get_num_radial_grid_points(context);
> 		//std::cout << "Number of radial points: " << num_radial_points << std::endl;
> 		compute_cap_der_on_grid(cap_der_mat,bs,grid_x_bohr,grid_y_bohr,grid_z_bohr,grid_w,num_points);
> 		delete [] grid_x_bohr;
> 		delete [] grid_y_bohr;
> 		delete [] grid_z_bohr;
> 		delete [] grid_w;
> 		numgrid_free_atom_grid(context);
> 	//}
> }
> void AOCAP::compute_cap_der_on_grid(std::map<char, Eigen::MatrixXd> &cap_der_mat,
> 					BasisSet bs,double* x, double* y, double* z, double *grid_w, int num_points)
> {
> 	Eigen::VectorXd cap_vals; Eigen::MatrixXd bf_values;
> 	bf_values = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 	std::vector<double> x_vec(x,x+num_points);
>     std::vector<double> y_vec(y,y+num_points);
>     std::vector<double> z_vec(z,z+num_points);
>     std::vector<double> w_vec(grid_w,grid_w+num_points);
>     //std::vector<double> cap_vec = cap_func(x_vec,y_vec,z_vec,w_vec);
> 
> 	std::map<char, std::vector<double>> derivative_map;
> 
> 	/*std::vector<double> x_derivative = cap_func_der_x();
> 	std::vector<double> y_derivative = cap_func_der_y();
> 	std::vector<double> z_derivative = cap_func_der_z();
> 	std::vector<double> cap_values_der(num_points);*/
> 	//std::cout << "\t" << cap_x << "\t" << cap_y <<"\t" << cap_z <<std::endl;
> 
> 	std::vector<double> x_derivative(num_points);
> 	std::vector<double> y_derivative(num_points);
> 	std::vector<double> z_derivative(num_points);
> 
>     for (size_t i = 0; i < num_points; i++) {
>     	double result = 0.0;
>         if (abs(x_vec[i]) > cap_x){
>         	if (x_vec[i] > 0.0){
>         		result =  2.0 * (abs(x_vec[i]) - cap_x) * w_vec[i];
>         	}else{
>         		result = -2.0 * (abs(x_vec[i]) - cap_x) * w_vec[i];
>         	}
>             x_derivative[i] = result;
>         }
>         else{
>         	x_derivative[i] = 0.0;
>         }
>     }
> 
>     for (size_t i = 0; i < num_points; i++) {
>     	double result = 0.0;
>         if (abs(y_vec[i]) > cap_y){
>         	if (y_vec[i] > 0.0){
>         		result =  2.0 * (abs(y_vec[i]) - cap_y) * w_vec[i];
>         	}else{
>         		result = -2.0 * (abs(y_vec[i]) - cap_y) * w_vec[i];
>         	}
>             y_derivative[i] = result;
>         }
>         else{
>         	y_derivative[i] = 0.0;
>         }
>     }
> 
>     for (size_t i = 0; i < num_points; i++) {
>     	double result = 0.0;
>         if (abs(z_vec[i]) > cap_z){
>         	if (z_vec[i] > 0.0){
>         		result =  2.0 * (abs(z_vec[i]) - cap_z) * w_vec[i];
>         	}else{
>         		result = -2.0 * (abs(z_vec[i]) - cap_z) * w_vec[i];
>         	}
>             z_derivative[i] = result;
>         }
>         else{
>         	z_derivative[i] = 0.0;
>         }
>     }
> 
>     /*
> 	std::vector<double> y_derivative(num_points);
>     for (size_t i = 0; i < num_points; i++) {
>         if (abs(y_vec[i]) > cap_y){
>             double result = 2.0 * (y_vec[i] - cap_y) * w_vec[i];
>          	y_derivative[i] = result;
>         }
>         else{
>         	y_derivative[i] = 0.0;
>         }
>     }
> 
> 	std::vector<double> z_derivative(num_points);
>     for (size_t i = 0; i < num_points; i++) {
>         if (abs(z_vec[i]) > cap_z){
>             double result = 2.0 * (z_vec[i] - cap_z) * w_vec[i];
>          	z_derivative[i] = result;
>         }
>         else{
>         	z_derivative[i] = 0.0;
>         }
>     }
> 	*/
> 
> 	derivative_map['x'] = x_derivative;
> 	derivative_map['y'] = y_derivative;
> 	derivative_map['z'] = z_derivative;
> 
> 	size_t bf_idx = 0;
> 	for(size_t i=0;i<bs.basis.size();i++)
> 	{
> 		Shell my_shell = bs.basis[i];
> 		std::vector<std::array<size_t,3>> order = opencap_carts_ordering(my_shell.l);
> 		for(size_t j=0;j<my_shell.num_carts();j++)
> 		{
> 			std::array<size_t,3> cart = order[j];
> 			my_shell.evaluate_on_grid(x,y,z,num_points,cart[0],cart[1],cart[2],bf_values.col(bf_idx));
> 			bf_idx++;
> 		}
> 	}
> 	for (char dir : {'x', 'y', 'z'}) {
> 		std::vector<double> cap_vec = derivative_map[dir];
> 		cap_vals = Eigen::Map<Eigen::VectorXd>(cap_vec.data(),cap_vec.size());
> 		Eigen::MatrixXd bf_prime;
> 		bf_prime =  Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 		for(size_t i=0;i<bf_prime.cols();i++){
> 			bf_prime.col(i) = bf_values.col(i).array()*cap_vals.array();
> 		}
> 		cap_der_mat[dir]+=bf_prime.transpose()*bf_values;
> 	}
> }
> /*void AOCAP::compute_ao_cap_der_mat(std::map<char, Eigen::MatrixXd> &cap_der_mat, BasisSet &bs)
> {
> 	if(!do_numerical)
> 	{
> 		std::cout << "CAP integrals cannot be computed analytically. (NYI), use 'do_numerical: True' in cap_dict" << std::endl;
> 		//eval_box_cap_analytical(cap_mat,bs);
> 		return;
> 	}
> 	else
> 		integrate_cap_der_numerical(cap_der_mat,bs);
> }*/
> 
> //Concluded: This part for the analogus numerical derivative for box cap derivative function.
> 
> 
> 
> //Following part: for the numerical derivative of the weight function. Used for gradient contribution.
> void AOCAP::compute_ao_cap_der_mat(std::vector<std::map<char, Eigen::MatrixXd>> &cap_der_mat_MD, BasisSet &bs)
> {
> 	if(!do_numerical)
> 	{
> 		std::cout << "CAP integrals will be computed analytically. (Not available yet)" << std::endl;
> 		//eval_box_cap_analytical(cap_mat,bs);
> 		return;
> 	}
> 	else
> 		integrate_cap_der_total_numerical(cap_der_mat_MD,bs);
> }
> 
> void AOCAP::integrate_cap_der_total_numerical(std::vector<std:: map<char, Eigen::MatrixXd>> &cap_der_mat_MD, BasisSet bs)
> {
> 	std::map<char, Eigen::MatrixXd> cap_der_mat;
> 	cap_der_mat['x'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	cap_der_mat['y'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	cap_der_mat['z'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	//integrate_cap_der_numerical(cap_der_mat, bs); //It does not depend on atoms
> 
> 	
> 	std::map<char, Eigen::MatrixXd> cap_mat_dwdR;
> 	std::map<char, Eigen::MatrixXd> cap_mat_dwdR_store;
> 	cap_mat_dwdR_store['x'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	cap_mat_dwdR_store['y'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	cap_mat_dwdR_store['z'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 
> 	cap_mat_dwdR['x'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	cap_mat_dwdR['y'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	cap_mat_dwdR['z'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 
> 	size_t num_atoms = atoms.size();
> 
> 	for(size_t i=0;i<num_atoms;i++){
> 		integrate_cap_der_numerical(cap_der_mat, bs, i);
> 		integrate_cap_dwdR_numerical(cap_mat_dwdR_store, bs, i);
> 		cap_mat_dwdR['x']=cap_mat_dwdR_store['x'];
> 		cap_mat_dwdR['y']=cap_mat_dwdR_store['y'];
> 		cap_mat_dwdR['z']=cap_mat_dwdR_store['z'];
> 		cap_mat_dwdR_store['x'].setZero();
> 		cap_mat_dwdR_store['y'].setZero();
> 		cap_mat_dwdR_store['z'].setZero();
> 
> 		std::map<char, Eigen::MatrixXd> sum_matrix;
> 		sum_matrix['x'] = cap_mat_dwdR['x'] + cap_der_mat['x'];
> 		sum_matrix['y'] = cap_mat_dwdR['y'] + cap_der_mat['y'];
> 		sum_matrix['z'] = cap_mat_dwdR['z'] + cap_der_mat['z'];
> 		cap_der_mat_MD.push_back(sum_matrix);
> 
> 		cap_mat_dwdR['x'].setZero();
> 		cap_mat_dwdR['y'].setZero();
> 		cap_mat_dwdR['z'].setZero();
> 
> 		cap_der_mat['x'].setZero();
> 		cap_der_mat['y'].setZero();
> 		cap_der_mat['z'].setZero();
> 
> 	}
> }
> 
> 
> void AOCAP::integrate_cap_dwdR_numerical(std::map<char, Eigen::MatrixXd> &cap_mat_dwdR_store, BasisSet bs, size_t atom_idx)
> {
> 	BeckeDW1 becke(atoms);
> 	python = true; // Initialize the Python flag
> 
> 	// funny business happens with GIL if we try to parallelize over atoms when custom python function is used
> 	if(cap_type=="custom")
> 		omp_set_num_threads(1);
> 	
> 	std::string msg = "Calculating CAP matrix (in AO basis) on grid with 1st order derivative of grid weight using "
>                   + std::to_string(omp_get_max_threads()) + " threads (Atom: " + std::to_string(atom_idx + 1) + ").";
> 
> 	if (python)
> 		pybind11::print(msg);
> 	else
> 		std::cout << msg << std::endl;
> 
> 	
> 	//std::cout << std::setprecision(2) << std::scientific  << "Radial precision: " << radial_precision
>     //          << " Angular points: " << angular_points << std::endl;
> 	size_t num_atoms = atoms.size();
>     	double x_coords_bohr[num_atoms];
> 	double y_coords_bohr[num_atoms];
> 	double z_coords_bohr[num_atoms];
> 	int nuc_charges[num_atoms];
> 	for(size_t i=0;i<num_atoms;i++)
> 	{
> 		x_coords_bohr[i]=atoms[i].coords[0];
> 		y_coords_bohr[i]=atoms[i].coords[1];
> 		z_coords_bohr[i]=atoms[i].coords[2];
> 		nuc_charges[i]=atoms[i].Z;
> 		if (atoms[i].Z==0)
> 			nuc_charges[i]=1; //choose bragg radius for H for ghost atoms
> 	}
>     int min_num_angular_points = angular_points;
>     int max_num_angular_points = angular_points;
> 	#pragma omp parallel for 
> 	for(size_t i=0;i<num_atoms;i++)
> 	{
>         // check parameters
>         double alpha_max = bs.alpha_max(atoms[i]);
>         std::vector<double> alpha_min = bs.alpha_min(atoms[i],thresh);
>         double r_inner = get_r_inner(radial_precision,
>                                      alpha_max * 2.0); // factor 2.0 to match DIRAC
>         double h = std::numeric_limits<float>::max();
>         double r_outer = 0.0;
>         for (int l = 0; l <= bs.max_L(); l++)
>         {
>             if (alpha_min[l] > 0.0)
>             {
>                 r_outer =
>                 std::max(r_outer,
>                          get_r_outer(radial_precision,
>                                      alpha_min[l],
>                                      l,
>                                      4.0 * get_bragg_angstrom(nuc_charges[i])));
>                 if(r_outer < r_inner)
>                 {
>                     opencap_throw("Error: r_outer < r_inner, grid cannot be allocated for this basis.");
>                     //std::cout << "Setting alpha min[l] to 0.01" << std::endl; 
>                     //alpha_min[l]=0.01;
>                 }
>                 else
>                 {
>                     h = std::min(h,
>                                  get_h(radial_precision, l, 0.1 * (r_outer - r_inner)));
>                     if(r_outer < h)
>                     {
>                         opencap_throw("Error: r_outer < h, grid cannot be allocated for this basis.");
>                     }
>                 }
>             }
>         }
>         context_t *context = numgrid_new_atom_grid(radial_precision,
> 		                                 min_num_angular_points,
> 		                                 max_num_angular_points,
> 		                                 nuc_charges[i],
> 		                                 bs.alpha_max(atoms[i]),
> 		                                 bs.max_L(),
> 		                                 alpha_min.data());
> 	int num_points = numgrid_get_num_grid_points(context);
>         double *grid_x_bohr = new double[num_points];
>         double *grid_y_bohr = new double[num_points];
>         double *grid_z_bohr = new double[num_points];
>         double *grid_w = new double[num_points];
> 
>         numgrid_get_grid(  context,
>                            num_atoms,
>                            i,
>                            x_coords_bohr,
>                            y_coords_bohr,
>                            z_coords_bohr,
>                            nuc_charges,
>                            grid_x_bohr,
>                            grid_y_bohr,
>                            grid_z_bohr,
>                            grid_w);
> 
> 	std::map<char, std::map<int, double>> dB_Weight; 
>     becke.calculate_gridW_derivative(context, atom_idx, dB_Weight, i);
> 
> 	/*
> 	if (i==atom_idx){
> 		int atomIndexToSave = atom_idx;  
> 	    	std::string filename = "weight_matrix_atom_" + std::to_string(atomIndexToSave) + "_numgrid.out";
> 	    	std::ofstream outputFile(filename);
> 
> 	    	if (outputFile.is_open()) {
> 			for (int ix = 0; ix < num_points; ++ix) {
> 	    	  //std::cout << "Inside loop: i = " << i << ", atom_idx = " << atom_idx << ", ix:  "<< ix <<std::endl;
> 		        double tmp_data = grid_w[ix];
> 		        outputFile << tmp_data << "\n";
> 			}
> 			outputFile.close();
> 	    	} else {
> 			std::cerr << "Unable to open file for writing: " << filename << std::endl;
> 	    	}
> 			}
> 	
> 	*/	
> 	
> 		compute_cap_on_grid_dwdR(cap_mat_dwdR_store,bs,grid_x_bohr,grid_y_bohr,grid_z_bohr, &dB_Weight, num_points);
> 
> 		delete [] grid_w;
> 		delete [] grid_x_bohr;
> 		delete [] grid_y_bohr;
> 		delete [] grid_z_bohr;
> 
> 		numgrid_free_atom_grid(context);
> 	}
> }
> 
> void AOCAP::compute_cap_on_grid_dwdR(std::map<char, Eigen::MatrixXd> &cap_mat_dwdR_store, BasisSet bs, double* x, double* y, double* z,
>                                      std::map<char, std::map<int, double>> *dB_Weight, int num_points) {
>     std::map<char, Eigen::VectorXd> cap_vals;
>     Eigen::MatrixXd bf_values(num_points, bs.num_carts());
>     std::vector<double> x_vec(x, x + num_points);
>     std::vector<double> y_vec(y, y + num_points);
>     std::vector<double> z_vec(z, z + num_points);
> 
>     for (char axis : {'x', 'y', 'z'}) {
>         std::map<int, double> &dir_map = (*dB_Weight)[axis]; 
>         std::vector<double> store_dWeight(num_points);   
>         for (int i = 0; i < num_points; ++i) {
>             store_dWeight[i] = dir_map[i]; 
>         }
>         std::vector<double> cap_vec = cap_func(x_vec, y_vec, z_vec, store_dWeight);
>         cap_vals[axis] = Eigen::VectorXd::Map(cap_vec.data(), cap_vec.size());
>     }
> 
>     size_t bf_idx = 0;
>     for (size_t i = 0; i < bs.basis.size(); i++) {
>         Shell my_shell = bs.basis[i];
>         std::vector<std::array<size_t, 3>> order = opencap_carts_ordering(my_shell.l);
>         for (size_t j = 0; j < my_shell.num_carts(); j++) {
>             std::array<size_t, 3> cart = order[j];
>             my_shell.evaluate_on_grid(x, y, z, num_points, cart[0], cart[1], cart[2], bf_values.col(bf_idx));
>             bf_idx++;
>         }
>     }
> 
>     for (char axis : {'x', 'y', 'z'}) {
>         Eigen::MatrixXd bf_prime(num_points, bs.num_carts());
>         bf_prime = bf_values.array().colwise() * cap_vals[axis].array();
>         cap_mat_dwdR_store[axis] += bf_prime.transpose() * bf_values;
>     }
> }
> 
> 
> void AOCAP::integrate_capG_numerical(std::vector<std:: map<char, Eigen::MatrixXd>> &capG_mat_MD, BasisSet bs)
> {
> 	std::map<char, Eigen::MatrixXd> capG_mat;
> 	capG_mat['x'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	capG_mat['y'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	capG_mat['z'] = Eigen::MatrixXd::Zero(bs.num_carts(), bs.num_carts());
> 	size_t num_atoms = atoms.size();
> 	for(size_t i=0;i<num_atoms;i++){
> 		integrate_capG_numerical_individual_atom(capG_mat,bs, i+1);
> 		capG_mat_MD.push_back(capG_mat);
> 		capG_mat['x'].setZero();
> 		capG_mat['y'].setZero();
> 		capG_mat['z'].setZero();
> 	}
> }
> 
> 
> void AOCAP::integrate_capG_numerical_individual_atom(std::map<char, Eigen::MatrixXd> &capG_mat, BasisSet bs, size_t Atom_idx)
> {
> 	// funny business happens with GIL if we try to parallelize over atoms when custom python function is used
> 	if(cap_type=="custom")
> 		omp_set_num_threads(1);
> 
> 	python = true; 
> 
> 	std::string message = "Calculating CAPG matrix (Atom: " + std::to_string(Atom_idx) + 
>                       ") in AO basis using " + std::to_string(omp_get_max_threads()) + " threads.";
> 
> 	if (python) {
> 		pybind11::print(message);
> 	} else {
> 		std::cout << message << std::endl;
> 	}
> 
> 	/*		
> 	std::cout << "Calculating CAPG matrix (Atom: " << Atom_idx <<") in AO basis using ";
> 	std::cout << to_string(omp_get_max_threads()) << " threads." << std::endl;
>     */
> 	size_t num_atoms = atoms.size();
>     double x_coords_bohr[num_atoms];
> 	double y_coords_bohr[num_atoms];
> 	double z_coords_bohr[num_atoms];
> 	int nuc_charges[num_atoms];
> 
> 	for(size_t i=0;i<num_atoms;i++)
> 	{
> 		x_coords_bohr[i]=atoms[i].coords[0];
> 		y_coords_bohr[i]=atoms[i].coords[1];
> 		z_coords_bohr[i]=atoms[i].coords[2];
> 		nuc_charges[i]=atoms[i].Z;
> 		if (atoms[i].Z==0)
> 			nuc_charges[i]=1; //choose bragg radius for H for ghost atoms
> 	}
> 
>     int min_num_angular_points = angular_points;
>     int max_num_angular_points = angular_points;
> 
> 	//#pragma omp parallel for 
> 	for(size_t i=0;i<num_atoms;i++)
> 	{
>         // check parameters
>         double alpha_max = bs.alpha_max(atoms[i]);
>         std::vector<double> alpha_min = bs.alpha_min(atoms[i],thresh);
>         double r_inner = get_r_inner(radial_precision,
>                                      alpha_max * 2.0); // factor 2.0 to match DIRAC
>         double h = std::numeric_limits<float>::max();
>         double r_outer = 0.0;
>         for (int l = 0; l <= bs.max_L(); l++)
>         {
>             if (alpha_min[l] > 0.0)
>             {
>                 r_outer =
>                 std::max(r_outer,
>                          get_r_outer(radial_precision,
>                                      alpha_min[l],
>                                      l,
>                                      4.0 * get_bragg_angstrom(nuc_charges[i])));
>                 if(r_outer < r_inner)
>                 {
>                     opencap_throw("Error: r_outer < r_inner, grid cannot be allocated for this basis.");
>                 }
>                 else
>                 {
>                     h = std::min(h,
>                                  get_h(radial_precision, l, 0.1 * (r_outer - r_inner)));
>                     if(r_outer < h)
>                     {
>                         opencap_throw("Error: r_outer < h, grid cannot be allocated for this basis.");
>                     }
>                 }
>             }
>         }
>         context_t *context = numgrid_new_atom_grid(radial_precision,
> 		                                 min_num_angular_points,
> 		                                 max_num_angular_points,
> 		                                 nuc_charges[i],
> 		                                 bs.alpha_max(atoms[i]),
> 		                                 bs.max_L(),
> 		                                 alpha_min.data());
> 		int num_points = numgrid_get_num_grid_points(context);
>         double *grid_x_bohr = new double[num_points];
>         double *grid_y_bohr = new double[num_points];
>         double *grid_z_bohr = new double[num_points];
>         double *grid_w = new double[num_points];
>         numgrid_get_grid(  context,
>                            num_atoms,
>                            i,
>                            x_coords_bohr,
>                            y_coords_bohr,
>                            z_coords_bohr,
>                            nuc_charges,
>                            grid_x_bohr,
>                            grid_y_bohr,
>                            grid_z_bohr,
>                            grid_w);
>         int num_radial_points = numgrid_get_num_radial_grid_points(context);
> 		computeG_cap_on_grid(capG_mat,bs,grid_x_bohr,grid_y_bohr,grid_z_bohr,grid_w,num_points, Atom_idx, i);
> 
> 		delete [] grid_x_bohr;
> 		delete [] grid_y_bohr;
> 		delete [] grid_z_bohr;
> 		delete [] grid_w;
> 		numgrid_free_atom_grid(context);
> 	}
> }
> 
> void AOCAP::computeG_cap_on_grid(std::map<char, Eigen::MatrixXd> &capG_mat,BasisSet bs,double* x, double* y, double* z, 
> double *grid_w, int num_points, size_t Atom_idx, size_t centre_numgrid)
> {
> 	Eigen::VectorXd cap_vals; Eigen::MatrixXd bf_values;
> 	Eigen::MatrixXd bfGrad_x_values; Eigen::MatrixXd bfGrad_y_values; Eigen::MatrixXd bfGrad_z_values;
> 	bf_values = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 	bfGrad_x_values = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 	bfGrad_y_values = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 	bfGrad_z_values = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 
>     std::vector<double> x_vec(x,x+num_points);
>     std::vector<double> y_vec(y,y+num_points);
>     std::vector<double> z_vec(z,z+num_points);
>     std::vector<double> w_vec(grid_w,grid_w+num_points);
>     std::vector<double> cap_vec = cap_func(x_vec,y_vec,z_vec,w_vec);
> 	size_t bf_idx = 0;
> 	for(size_t i=0;i<bs.basis.size();i++)
> 	{
> 		Shell my_shell = bs.basis[i];
> 		std::vector<std::array<size_t,3>> order = opencap_carts_ordering(my_shell.l);
> 		for(size_t j=0;j<my_shell.num_carts();j++)
> 		{
> 			std::array<size_t,3> cart = order[j];
> 			if (bf_values_store.size()<atoms.size())
> 			{
> 				my_shell.evaluate_on_grid(x,y,z,num_points,cart[0],cart[1],cart[2],bf_values.col(bf_idx)); //evaluate_on_grid function
> 			}
> 			my_shell.evaluateG_on_grid(x,y,z,num_points,cart[0],cart[1],cart[2],
> 			bfGrad_x_values.col(bf_idx), bfGrad_y_values.col(bf_idx), bfGrad_z_values.col(bf_idx), Atom_idx); //evaluateG_on_grid function	
> 			bf_idx++;
> 		}
> 	}
> 	if (bf_values_store.size()<atoms.size())
> 	{
> 		bf_values_store.push_back(bf_values);
> 	}
> 	bf_values = bf_values_store[centre_numgrid];
> 
>     cap_vals = Eigen::Map<Eigen::VectorXd>(cap_vec.data(),cap_vec.size());
> 	Eigen::MatrixXd bf_prime_x = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 	Eigen::MatrixXd bf_prime_y = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 	Eigen::MatrixXd bf_prime_z = Eigen::MatrixXd::Zero(num_points,bs.num_carts());
> 
> 	//#pragma omp parallel for
> 	for(size_t i=0;i<bf_prime_x.cols();i++){
> 		bf_prime_x.col(i) = bfGrad_x_values.col(i).array()*cap_vals.array();		
> 		bf_prime_y.col(i) = bfGrad_y_values.col(i).array()*cap_vals.array();		
> 		bf_prime_z.col(i) = bfGrad_z_values.col(i).array()*cap_vals.array();		
> 	}
> 	//capG_mat+=bf_prime.transpose()*bf_values + bf_values.transpose()*bf_prime; //bra vector is the gradient
> 	capG_mat['x'] += bf_prime_x.transpose() * bf_values + bf_values.transpose() * bf_prime_x;
> 	capG_mat['y'] += bf_prime_y.transpose() * bf_values + bf_values.transpose() * bf_prime_y;
> 	capG_mat['z'] += bf_prime_z.transpose() * bf_values + bf_values.transpose() * bf_prime_z;
> 
> }
> 
> void AOCAP::computeG_ao_cap_mat(std::vector<std::map<char, Eigen::MatrixXd>> &capG_mat_MD, BasisSet &bs)
> {
> 	if(!do_numerical)
> 	{
> 		std::cout << "CAP integrals will be computed analytically. (Not available yet)" << std::endl;
> 		//eval_box_cap_analytical(cap_mat,bs);
> 		return;
> 	}
> 	else
> 		integrate_capG_numerical(capG_mat_MD,bs);
> }
> 
322d1021
< 
Only in ../OPENCAP-MD-NOV30/opencap/src: BeckeDW1.cpp
diff -r ./opencap/src/CAP.cpp ../OPENCAP-MD-NOV30/opencap/src/CAP.cpp
135a136,137
> 		else if(compare_strings(method,"sa-casscf"))
> 			ZERO_ORDER_H = read_sacasscf_h(nstates,parameters["molcas_output"],rotation_matrix);
230a233,296
> void CAP::compute_projected_capG()
> {
>     if (AO_CAPG_MAT.empty()) {
>         integrate_capG();
>     }
>     verify_data();
>     for (std::map<char, Eigen::MatrixXd>& matX : AO_CAPG_MAT) {
>         std::map<char, Eigen::MatrixXd> CAPG_matrix;
>         CAPG_matrix['x'] = Eigen::MatrixXd::Zero(nstates, nstates);
>         CAPG_matrix['y'] = Eigen::MatrixXd::Zero(nstates, nstates);
>         CAPG_matrix['z'] = Eigen::MatrixXd::Zero(nstates, nstates);
> 
>         for (char axis : {'x', 'y', 'z'}) {
>             for (size_t row_idx = 0; row_idx < CAPG_matrix[axis].rows(); row_idx++) 
> 			{
>                 for (size_t col_idx = 0; col_idx < CAPG_matrix[axis].cols(); col_idx++) 
> 				{
>                     Eigen::MatrixXd alpha_mat_prod = alpha_dms[row_idx][col_idx] * matX[axis];
>                     Eigen::MatrixXd beta_mat_prod = beta_dms[row_idx][col_idx] * matX[axis];
>                     CAPG_matrix[axis](row_idx, col_idx) = alpha_mat_prod.trace() + beta_mat_prod.trace();
>                     CAPG_matrix[axis](row_idx, col_idx) = -1.0 * CAPG_matrix[axis](row_idx, col_idx);
>                 }
>             }
>             if (rotation_matrix.cols() != 0) {
>                 std::cout << "Warning: rotating CAP matrix (U^dagger*W*U) using the following rotation matrix U:" << std::endl << rotation_matrix << std::endl;
>                 CAPG_matrix[axis] = rotation_matrix.transpose() * CAPG_matrix[axis] * rotation_matrix;
>             }
>         }
>         CAPG_MAT.push_back(CAPG_matrix);
>     }
> }
> 
> void CAP::compute_projected_cap_der()
> {
> 	if (AO_CAP_DER_MAT.empty()) {
>         integrate_cap_der();
>     }
>     verify_data();
>     for (std::map<char, Eigen::MatrixXd>& matX : AO_CAP_DER_MAT) {
>         std::map<char, Eigen::MatrixXd> CAP_der_matrix;
>         CAP_der_matrix['x'] = Eigen::MatrixXd::Zero(nstates, nstates);
>         CAP_der_matrix['y'] = Eigen::MatrixXd::Zero(nstates, nstates);
>         CAP_der_matrix['z'] = Eigen::MatrixXd::Zero(nstates, nstates);
> 
>         for (char axis : {'x', 'y', 'z'}) {
>             for (size_t row_idx = 0; row_idx < CAP_der_matrix[axis].rows(); row_idx++) 
> 			{
>                 for (size_t col_idx = 0; col_idx < CAP_der_matrix[axis].cols(); col_idx++) 
> 				{
>                     Eigen::MatrixXd alpha_mat_prod = alpha_dms[row_idx][col_idx] * matX[axis];
>                     Eigen::MatrixXd beta_mat_prod = beta_dms[row_idx][col_idx] * matX[axis];
>                     CAP_der_matrix[axis](row_idx, col_idx) = alpha_mat_prod.trace() + beta_mat_prod.trace();
>                     CAP_der_matrix[axis](row_idx, col_idx) = -1.0 * CAP_der_matrix[axis](row_idx, col_idx);
>                 }
>             }
>             if (rotation_matrix.cols() != 0) {
>                 std::cout << "Warning: rotating CAP matrix (U^dagger*W*U) using the following rotation matrix U:" << std::endl << rotation_matrix << std::endl;
>                 CAP_der_matrix[axis] = rotation_matrix.transpose() * CAP_der_matrix[axis] * rotation_matrix;
>             }
>         }
>         CAP_DER_MAT.push_back(CAP_der_matrix);
>     }
> }
> 
248a315,371
> void CAP::integrate_capG()
> {
>     std::vector<std::map<char, Eigen::MatrixXd>> capG_mat_MD;
> 
>     auto start = std::chrono::high_resolution_clock::now();
>     cap_integrator.computeG_ao_cap_mat(capG_mat_MD, system.bs);
>     auto stop = std::chrono::high_resolution_clock::now();
>     auto total_time = std::chrono::duration<double>(stop - start).count();
>     if (python)
>         py::print("Integration time:" + std::to_string(total_time));
>     else
>         std::cout << "Integration time:" << std::to_string(total_time) << std::endl;
> 
>     for (const std::map<char, Eigen::MatrixXd>& matX : capG_mat_MD) {
>         std::map<char, Eigen::MatrixXd> capG_spherical;
>         capG_spherical['x'] = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
>         capG_spherical['y'] = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
>         capG_spherical['z'] = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
> 
>         for (char axis : {'x', 'y', 'z'}) {
>             Eigen::MatrixXd matX_copy = matX.at(axis).eval();  // Make a copy of the matrix.
>             uniform_cart_norm(matX_copy, system.bs);
>             cart2spherical(matX_copy, capG_spherical[axis], system.bs);
>         }
> 
>         AO_CAPG_MAT.push_back(capG_spherical);
>     }
> }
> 
> void CAP::integrate_cap_der()
> {
> 	std::vector<std::map<char, Eigen::MatrixXd>> cap_der_mat_MD;
> 
>     auto start = std::chrono::high_resolution_clock::now();
>     cap_integrator.compute_ao_cap_der_mat(cap_der_mat_MD, system.bs);
>     auto stop = std::chrono::high_resolution_clock::now();
>     auto total_time = std::chrono::duration<double>(stop - start).count();
>     if (python)
>         py::print("Integration time:" + std::to_string(total_time));
>     else
>         std::cout << "Integration time:" << std::to_string(total_time) << std::endl;
> 
>     for (const std::map<char, Eigen::MatrixXd>& matX : cap_der_mat_MD) {
>         std::map<char, Eigen::MatrixXd> cap_der_spherical;
>         cap_der_spherical['x'] = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
>         cap_der_spherical['y'] = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
>         cap_der_spherical['z'] = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
> 
>         for (char axis : {'x', 'y', 'z'}) {
>             Eigen::MatrixXd matX_copy = matX.at(axis).eval();  // Make a copy of the matrix.
>             uniform_cart_norm(matX_copy, system.bs);
>             cart2spherical(matX_copy, cap_der_spherical[axis], system.bs);
>         }
>         AO_CAP_DER_MAT.push_back(cap_der_spherical);
>     }
> }
> 
373c496
< 		std::vector<std::string> supported = {"ms-caspt2","xms-caspt2","pc-nevpt2","sc-nevpt2"};
---
> 		std::vector<std::string> supported = {"ms-caspt2","xms-caspt2","pc-nevpt2","sc-nevpt2", "sa-casscf"};
433a557
> 		//std::cout << "LOOK HERE"<< AO_CAP_MAT << std::endl;
464c588,629
< 
---
> std::vector<std::map<char, Eigen::MatrixXd>> CAP::get_ao_capG(std::string ordering,std::string basis_file)
> {
>     if (AO_CAPG_MAT.empty()){
>        	integrate_capG();
> 	}
> 	size_t matX_idx=0;
> 	//std::map<char, Eigen::MatrixXd> reordered_cap;
> 	if(ordering!="") {
> 		for (std::map<char, Eigen::MatrixXd>& reordered_cap : AO_CAPG_MAT){
> 			for (char axis : {'x', 'y', 'z'}){
>         		//reordered_cap[axis] = matX[axis];
>         		std::vector<bf_id> ids;
>         		if(compare_strings(ordering,"pyscf"))
>         			ids = get_pyscf_ids(system.bs);
>         		else if(compare_strings(ordering,"openmolcas"))
>         		{
>             		if(basis_file=="")
>             		opencap_throw("Error: OpenMolcas ordering requires a valid HDF5 file "
>                           	"specified with the basis_file optional argument.");
>             		ids = get_molcas_ids(system.bs,basis_file);
>         		}
>         		else if(compare_strings(ordering,"qchem"))
>             		ids = get_qchem_ids(system.bs);
>         		else if(compare_strings(ordering,"psi4"))
>             		ids = get_psi4_ids(system.bs);
>         		else if(compare_strings(ordering,"bagel"))
>             		ids = get_bagel_ids(system.bs);
>         		else if(compare_strings(ordering,"molden"))
>             		ids = system.bs.bf_ids;
>         		else
>             		opencap_throw("Error: " + ordering +" is unsupported.");
>         		reorder_matrix(reordered_cap[axis],system.bs.bf_ids,ids);
> 			}
> 			AO_CAPG_MAT[matX_idx] = reordered_cap;
> 			matX_idx +=1;
>     	}
> 		return AO_CAPG_MAT;
> 	}
> 	
>     return AO_CAPG_MAT;
>     
> }
469c634,641
< 
---
> std::vector<std::map<char, Eigen::MatrixXd>> CAP::get_projected_capG()
> {
> 	return CAPG_MAT;
> }
> std::vector<std::map<char, Eigen::MatrixXd>> CAP::get_projected_cap_der()
> {
> 	return CAP_DER_MAT;
> }
529a702,753
> 
> Eigen::MatrixXd CAP::qcsoftware_to_opencap_ordering(Eigen::MatrixXd mat_in, std::string ordering, std::string basis_file)
> {
>     std::cout << "Returns " << ordering << " to OpenCAP ordering for a matrix.\n" << std::endl;
>     std::vector<bf_id> input_ids;
> 
>     std::vector<std::tuple<int, int>> swap_indices;
> 
>     if (compare_strings(ordering, "pyscf"))
>         input_ids = get_pyscf_ids(system.bs);
>     else if (compare_strings(ordering, "openmolcas"))
>     {
>         if (basis_file == "")
>             opencap_throw("Error: OpenMolcas ordering requires a valid HDF5 file "
>                           "specified with the basis_file optional argument.");
>         input_ids = get_molcas_ids(system.bs, basis_file);
>     }
>     else if (compare_strings(ordering, "qchem"))
>         input_ids = get_qchem_ids(system.bs);
>     else if (compare_strings(ordering, "psi4"))
>         input_ids = get_psi4_ids(system.bs);
>     else if (compare_strings(ordering, "molden"))
>         input_ids = system.bs.bf_ids;
>     else if (compare_strings(ordering, "bagel"))
>         input_ids = get_bagel_ids(system.bs);
>     else
>         opencap_throw("Error: " + ordering + " is unsupported.");
> 
>     for (size_t i = 0; i < input_ids.size(); i++)
>     {
>         for (size_t j = 0; j < system.bs.bf_ids.size(); j++)
>         {
>             if (input_ids[i] == system.bs.bf_ids[j])
>             {
>                 swap_indices.push_back(std::make_tuple(i, j));
>             }
>         }
>     }
> 
>     Eigen::MatrixXd per_mat(system.bs.Nbasis, system.bs.Nbasis);
>     per_mat = Eigen::MatrixXd::Zero(system.bs.Nbasis, system.bs.Nbasis);
> 
>     for (auto t : swap_indices)
>         per_mat(std::get<0>(t), std::get<1>(t)) = 1;
> 
>     // permute indices: P^T * A * P
>     Eigen::MatrixXd mat_out(system.bs.Nbasis, system.bs.Nbasis);
>     mat_out = per_mat.transpose() * mat_in * per_mat;
> 
>     return mat_out;
> }
> 
diff -r ./opencap/src/Shell.cpp ../OPENCAP-MD-NOV30/opencap/src/Shell.cpp
131,132c131,133
< 
< void Shell::add_primitive(double exp,double coeff)
---
> void Shell::evaluateG_on_grid(double* x, double* y, double* z, int num_points, size_t lx, size_t ly, size_t lz,
>                              Eigen::Ref<Eigen::VectorXd> vgrad_X, Eigen::Ref<Eigen::VectorXd> vgrad_Y,
>                              Eigen::Ref<Eigen::VectorXd> vgrad_Z, size_t Atom_idx)
134,136c135,202
< 	exps.push_back(exp);
< 	coeffs.push_back(coeff);
< 	num_prims = exps.size();
---
>     #pragma omp parallel for
>     for (size_t i = 0; i < num_points; i++)
>     {
>         double r_squared = pow(x[i] - origin[0], 2.0) + pow(y[i] - origin[1], 2.0) + pow(z[i] - origin[2], 2.0);
>         double grad_x = 0.0;
>         double grad_y = 0.0;
>         double grad_z = 0.0;
> 
>         for (size_t j = 0; j < num_prims; j++)
>         {
>             if (atom_ids[j] != Atom_idx)
>                 continue;
> 
>             double nabla_x = 0.0;
>             double nabla_y = 0.0;
>             double nabla_z = 0.0;
> 
>             if (lx == 0)
>             {
>                 nabla_x = (2.0 * exps[j]) * (x[i] - origin[0]) *
>                           coeffs[j] * pow(x[i] - origin[0], lx) * pow(y[i] - origin[1], ly) *
>                           pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]);
>             }
>             else
>             {
>                 nabla_x = (-1.0* lx) * coeffs[j] * pow(x[i] - origin[0], lx - 1) * pow(y[i] - origin[1], ly) *
>                           pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]) +
>                           2.0 * exps[j] * (x[i] - origin[0]) * coeffs[j] * pow(x[i] - origin[0], lx) *
>                           pow(y[i] - origin[1], ly) * pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]);
>             }
> 
>             if (ly == 0)
>             {
>                 nabla_y = (2.0 * exps[j]) * (y[i] - origin[1]) *
>                           coeffs[j] * pow(x[i] - origin[0], lx) * pow(y[i] - origin[1], ly) *
>                           pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]);
>             }
>             else
>             {
>                 nabla_y = (-1.0* ly) * coeffs[j] * pow(x[i] - origin[0], lx) * pow(y[i] - origin[1], ly - 1) *
>                           pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]) +
>                           2.0 * exps[j] * (y[i] - origin[1]) * coeffs[j] * pow(x[i] - origin[0], lx) *
>                           pow(y[i] - origin[1], ly) * pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]);
>             }
> 
>             if (lz == 0)
>             {
>                 nabla_z = (2.0 * exps[j]) * (z[i] - origin[2]) *
>                           coeffs[j] * pow(x[i] - origin[0], lx) * pow(y[i] - origin[1], ly) *
>                           pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]);
>             }
>             else
>             {
>                 nabla_z = (-1.0 * lz) * coeffs[j] * pow(x[i] - origin[0], lx) * pow(y[i] - origin[1], ly) *
>                           pow(z[i] - origin[2], lz - 1) * pow(euler, -1.0 * r_squared * exps[j]) +
>                           2.0 * exps[j] * (z[i] - origin[2]) * coeffs[j] * pow(x[i] - origin[0], lx) *
>                           pow(y[i] - origin[1], ly) * pow(z[i] - origin[2], lz) * pow(euler, -1.0 * r_squared * exps[j]);
>             }
> 	
>             grad_x += nabla_x;
>             grad_y += nabla_y;
>             grad_z += nabla_z;
>         }
> 
>         vgrad_X(i) = grad_x;
>         vgrad_Y(i) = grad_y;
>         vgrad_Z(i) = grad_z;
>     }
139,141c205,211
< bool Shell::operator==(const Shell& other)
< {
< 	return l == other.l && exps == other.exps && coeffs==other.coeffs && origin==other.origin;
---
> 
> void Shell::add_primitive(double exp, double coeff, size_t atom_id) {
>     exps.push_back(exp);
>     coeffs.push_back(coeff);
>     num_prims = exps.size();
> 	atom_ids.push_back(atom_id);
>     //std::cout << "Atom id: " << atom_id << std::endl;
144a215
> void Shell::grad_atoms(std::vector<size_t> unique_atoms){
145a217,223
> 	for( int idx: atom_ids){
> 		if (std::find(atom_ids.begin(), atom_ids.end(), idx) != atom_ids.end()) {
>     	grad_atom.push_back(idx);
> 		}
> 	}
> 	unique_atoms = grad_atom;
> }
146a225,228
> bool Shell::operator==(const Shell& other)
> {
> 	return l == other.l && exps == other.exps && coeffs==other.coeffs && origin==other.origin;
> }
diff -r ./opencap/src/cap_types.cpp ../OPENCAP-MD-NOV30/opencap/src/cap_types.cpp
106c106,107
< }
\ No newline at end of file
---
> }
> 
diff -r ./opencap/src/molcas_interface.cpp ../OPENCAP-MD-NOV30/opencap/src/molcas_interface.cpp
273a274,317
> Eigen::MatrixXd read_sacasscf_h(size_t nstates, std::string filename, Eigen::MatrixXd &rotation_matrix) {
>     Eigen::MatrixXd ZERO_ORDER_H(nstates, nstates);
>     ZERO_ORDER_H = Eigen::MatrixXd::Zero(nstates, nstates);
>     std::vector<double> energies;
> 
>     std::ifstream file(filename);
>     if (!file.is_open()) {
>         std::cerr << "Error opening the file: " << filename << std::endl;
>         return ZERO_ORDER_H;
>     }
> 
>     std::string line;
>     std::string searchStr = "HAMILTONIAN MATRIX FOR THE ORIGINAL STATES:";
>     bool foundEnergies = false;
>     size_t energiesRead = 0;
>     while (std::getline(file, line) && energiesRead < nstates) {
>         if (foundEnergies) {
>             std::istringstream iss(line);
>             double energy;
>             while (iss >> energy) {
>                 energies.push_back(energy);
>                 energiesRead++;
>                 if (energiesRead >= nstates) {
>                     break;
>                 }
>             }
>         } else if (line.find(searchStr) != std::string::npos) {
>             // Skip the next two lines
>             std::getline(file, line); // Skip "Diagonal, with energies" line
>             std::getline(file, line); // Skip the empty line after the header
>             foundEnergies = true;
>         }
>     }
> 
>     file.close();
>     for (size_t i = 0; i < nstates; i++)
>         ZERO_ORDER_H(i, i) = energies[i];
> 
>     // Use the provided rotation_matrix
> 
>     return ZERO_ORDER_H;
> }
> 
> 
459c503
< 			bs.basis[bs_idx].add_primitive(exp,coeff);
---
> 			bs.basis[bs_idx].add_primitive(exp,coeff,ctr); //SBK added ctr variable which acts as Atom No. (Needed for openCAPMD)
diff -r ./opencap/src/molden_parser.cpp ../OPENCAP-MD-NOV30/opencap/src/molden_parser.cpp
107c107,108
< Shell read_shell_from_molden(std::string line,std::ifstream &is,std::array<double,3> cur_coords)
---
> Shell read_shell_from_molden(std::string line,std::ifstream &is,std::array<double,3> cur_coords, size_t atom_id)
> // SBK added "atom_id" here for opencapMD
125c126
< 		my_shell.add_primitive(exp,coeff);
---
> 		my_shell.add_primitive(exp,coeff,atom_id); //SBK added extra args: "atom_id" here for opencapMD.
169c170,172
< 				Shell my_shell = read_shell_from_molden(line,is,atoms[atm_idx].coords);
---
> 				Shell my_shell = read_shell_from_molden(line,is,atoms[atm_idx].coords, atm_idx+1);
> 													// SBK added extra args: "atom_id" here for opencapMD.
> 													// `atm_idx+1` cause atom number is read from 1 in Shell.cpp.
diff -r ./opencap/src/qchem_interface.cpp ../OPENCAP-MD-NOV30/opencap/src/qchem_interface.cpp
474a475,477
> 		/*for (size_t ct=0;ct<num_elements;ct++){
> 		std ::cout << atom_ids[ct] << "\n"<< std::endl;
> 		}*/
547,548c550,551
< 				s_shell.add_primitive(exps[prim_idx],coeffs[prim_idx]);
< 				p_shell.add_primitive(exps[prim_idx],p_coeffs[prim_idx]);
---
> 				s_shell.add_primitive(exps[prim_idx],coeffs[prim_idx],atom_ids[i]);
> 				p_shell.add_primitive(exps[prim_idx],p_coeffs[prim_idx],atom_ids[i]);
562c565
< 				new_shell.add_primitive(exps[prim_idx],coeffs[prim_idx]);
---
> 				new_shell.add_primitive(exps[prim_idx],coeffs[prim_idx],atom_ids[i]); //SBK modified this
Only in ../OPENCAP-MD-NOV30/pyopencap: .DS_Store
diff -r ./pyopencap/analysis/ColumbusParser.py ../OPENCAP-MD-NOV30/pyopencap/analysis/ColumbusParser.py
1c1
< '''Copyright (c) 2022 James Gayvert, Soubhik Mondal
---
> '''Copyright (c) 2024 James Gayvert, Soubhik Mondal
438a439,731
> 
> 
> 
> class colparser_mc():
>     '''
>     A class that parses COLUMBUS electronic structure package generated files
>     to generate state density and transition density matrices for projected-CAP
>     calculation on MCSCF level.
>     '''
> 
>     def _set_mo_coeff(self,ordering=None):
>         '''
>         An internal function to generate mo coffiecients in proper ordering.
> 
>         Returns
>         -------
>         MO coefficients in proper ordering to that of pyopencap internal structure
>         '''
> 
>         if ordering is not None:
>             raise NotImplementedError("Custom ordering NYI.")
>         else:
>             mo_coeff = np.zeros((len(self.mos),len(self.mos)))
>             for i, mo in enumerate(self.mos):
>                 mo_coeff[:,i] = mo.coeffs
>             self.mo_coeff = mo_coeff
> 
> 
>     def _read_molden(self,molden_file):
>         '''
>         An internal function that parses standard molden file.
> 
>         Parameters
>         ----------
>         molden_file : str
>             molden MO filename (generated in MOLDEN/ folder in COLUMBUS calculation Directory
>             if 'molden' keyword is invoked in control.run runfile.))
> 
>         Returns
>         -------
>         mos : np.ndarray
>             MO coefficients.
>         '''
> 
>         _SEC_REGEX = re.compile(r'\[[^]]+\]')
>         irrep_dict = {}
>         with open(molden_file,'r') as f:
>             line = f.readline()
>             while '[MO]' not in line:
>                 line = f.readline()
>             cur_mo = None
>             mos = []
>             line = f.readline()
>             new_sec = _SEC_REGEX.match(line)
>             while new_sec is None and len(line.strip())!=0:
>                 if 'sym=' in line.lower():
>                     if cur_mo is not None:
>                         mos.append(cur_mo)
>                     cur_mo = MO(line,len(mos)+1)
>                     if cur_mo.irrep in irrep_dict:
>                         irrep_dict[cur_mo.irrep] = irrep_dict[cur_mo.irrep]+1
>                     else:
>                         irrep_dict[cur_mo.irrep] = 1
>                 elif 'ene=' in line.lower():
>                     pass
>                 elif 'spin' in line.lower():
>                     pass
>                 elif 'occup' in line.lower():
>                     pass
>                 elif len(line.strip())!=0:
>                     coeff = float(line.split()[1])
>                     cur_mo.add_coeff(coeff)
>                 line = f.readline()
>                 new_sec = _SEC_REGEX.match(line)
>             mos.append(cur_mo)
>         return mos
> 
> 
>     def __init__(self, molden_file):
>         '''
>         Initializes the colparser class
> 
>         Parameters
>         ----------
>         molden_file: str
>             molden MO filename (generated in MOLDEN/ folder in COLUMBUS calculation Directory)
> 
>         '''
>         self.mos = self._read_molden(molden_file)
>         self._set_mo_coeff()
> 
> 
>     '''
>     The following parser is adapted from TheoDORE
>     '''
> 
>     def read_iwfmt(self, dens, filen, fac = 1.):
>         """
>         Read output from iwfmt.x for a 1-particle density file.
>         """
> 
>         in_data=False
>         _AO_MAT = False
>         
>         rfile = open(filen, 'r')
>         while True:
>             try:
>                 line=next(rfile)
>             except StopIteration:
>                 break
>             if ' 0.000000000000E+00' in line:
>                 if len(line.split()) == 1:
>                     words = last_line.split()
>                     (num,lab1,ibvtyp,itypea,itypeb,ifmt,last,nipv) = [int(word) for word in words]
>                     if itypea==0 and itypeb==7:
>                         #print(' Reading symmetric density ...')
>                         in_data=True
>                         sym = 1
>                     elif itypea==2 and itypeb==9:
>                         #print(' Reading antisymmetric density ...')
>                         in_data=True
>                         sym = -1
>                     elif itypea==0 and itypeb==0:
>                         in_data = True
>                         _AO_MAT = True
>                     else:
>                         #print('Warning: this section does not contain a density')
>                         #print('itypea: %i, itypeb: %i'%(itypea,itypeb))
>                         #print(last_line)
>                         in_data=False
>             elif '    ' in line:
>                 pass
>             elif in_data:
>                 words = line.split()
> 
>                 val = float(words[0])
>                 i = int(words[1])-1
>                 j = int(words[2])-1
>                 
>                 if not _AO_MAT:
>                 #if 0.2 < abs(val) < 1.9999: print("(i,j)=(%2i,%2i), val=%6.3f"%(i,j,val))
>                     dens[j,i] += fac * val
> 
>                     if i != j: dens[i,j] += fac * sym * val
>                 elif _AO_MAT:
>                     dens[j,i] = fac * val
> 
>             last_line = line
> 
>         return
> 
>     def tdm_ao(self, iFROM, iTO, data_dir='.', filename=None):
>         '''
>         Returns transition density matrix in atomic orbital basis by parsing a Columbus mcsd1fl.iwfmt file.
> 
>         Parameters
>         ----------
>         iFROM, iTO : int
>             Initial state index and final state indices respectively.
>         data_dir: str, optional
>             Directory to search for .iwfmt file. Should not be used in conjunction with `filename` kwarg
>         filename: str, optional
>             Path to file to parse. If not specified, the filename is assumed to be mcsd1fl.drt1.st%2.2i-st%2.2i.iwfmt'%(iFROM, iTO)
>             in the current directory.
> 
>         Returns
>         -------
>         tdm: np.ndarray
>             Transition density matrix in AO basis
>         '''
>         if filename is None:
>             fnameIN =os.path.join(data_dir,'mcsd1fl.drt1.st%2.2i-st%2.2i.iwfmt'%(iFROM, iTO))
>         else:
>             fnameIN = filename
>             
>         _tdm_AO = np.zeros(np.shape(self.mo_coeff))
> 
>         # read symmetric part
>         self.read_iwfmt(_tdm_AO, fnameIN)
>         # read antisymmetric part
>         self.read_iwfmt(_tdm_AO, fnameIN.replace('mcsd1fl', 'mcad1fl'))
> 
>         return self.mo_coeff @ _tdm_AO @ self.mo_coeff.T
>     
>     
>     def sdm_ao(self, i, DRTn=1, data_dir='.', filename=None):
>         '''
>         Returns state density matrix in atomic orbital basis by parsing a Columbus mcsd1fl.iwfmt file.
> 
>         Parameters
>         ----------
>         i : int
>             State index
>         DRTn : int, optional
>             DRT index
>         data_dir: str, optional
>             Directory to search for .iwfmt file. Should not be used in conjunction with `filename` kwarg
>         filename: str, optional
>             Path to file to parse. If not specified, the filename is assumed to be mcsd1fl.drt1.st%2.2i.iwfmt'%(i)
>             in the current directory.
> 
>         Returns
>         -------
>         sdm: np.ndarray
>             State density matrix in AO basis
> 
>         '''
>         if filename is None:
>             fnameIN =os.path.join(data_dir,'mcsd1fl.drt1.st%2.2i.iwfmt'%(i))
>         else:
>             fnameIN = filename
>             
>         _sdm_AO = np.zeros(np.shape(self.mo_coeff))
>         self.read_iwfmt(_sdm_AO, fnameIN)
>         
>         return self.mo_coeff @ _sdm_AO @ self.mo_coeff.T
>     
>     '''
>     def read_mc_tden(self, state1, state2, filen):
>         tdm_AO = np.zeros(np.shape(self.mo_coeff))
> 
>         # read symmetric part
>         self.read_iwfmt(tdm_AO, filen, fac=1/numpy.sqrt(2.))
>         # read antisymmetric part
>         self.read_iwfmt(tdm_AO, filen.replace('mcsd1fl', 'mcad1fl'), fac=1/numpy.sqrt(2.))
>         return self.mo_coeff @ tdm_AO @ self.mo_coeff.T
>     
>     def read_mc_sden(self, state, filen):
> 
>         sdm_AO = np.zeros(np.shape(self.mo_coeff))
> 
>         self.read_iwfmt(sdm_AO, filen)
>         
>         return self.mo_coeff @ sdm_AO @ self.mo_coeff.T
>     '''
>     
>     def get_H0(self, filename='mcscfsm'):
>         '''
>         Parses energies from a Columbus mcscfsm file. 
> 
>         Parameters
>         ----------
>         filename: str, optional
>             Path to Columbus ciudgsm file located in WORK directory. If unspecified, assumed to be './ciudgsm'.
> 
>         Returns
>         --------
>         H0_mat : np.ndarray
>             Diagonal hamiltonian with MCSCF energies.
> 
>         '''
>         with open(filename, 'r') as fmc:
>             fmclines = fmc.readlines()
>         
>         energy_drt = []
>         for idx, line in enumerate(fmclines):
>             if "Individual total energies for all states" in line:
>                 for mcline in fmclines[idx+1:]:
>                     if 'DRT' in mcline:
>                         energy_drt.append(float(mcline.split()[9].replace(',', '')))
>                 break
>     
>         self.H0_mat = np.diag(energy_drt)
> 
>         return self.H0_mat
>     
>     def ao_overlap(self, data_dir='.', filename=None):
>         '''
>         Returns state AO overlap matrix by parsing a Columbus aoints.iwfmt file.
> 
>         Parameters
>         ----------
>         data_dir: str, optional
>             Directory to search for .iwfmt file. Should not be used in conjunction with `filename` kwarg
>         filename: str, optional
>             Path to file to parse. If not specified, the filename is assumed to be aoints.iwfmt
>             in the current directory.
> 
>         Returns
>         -------
>         sdm: np.ndarray
>             AO overlap matrix
> 
>         '''
>         if filename is None:
>             fnameIN =os.path.join(data_dir,'aoints.iwfmt')
>         else:
>             fnameIN = filename
>             
>         ovlp_AO = np.zeros(np.shape(self.mo_coeff))
>         self.read_iwfmt(ovlp_AO, fnameIN)
>         
>         return ovlp_AO
diff -r ./pyopencap/analysis/__init__.py ../OPENCAP-MD-NOV30/pyopencap/analysis/__init__.py
24c24
< from .ColumbusParser import colparser
---
> from .ColumbusParser import colparser, colparser_mc
Only in ../OPENCAP-MD-NOV30: pyopencap.egg-info
Only in .: tmp
